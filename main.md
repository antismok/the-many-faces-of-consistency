The many faces of consistency
Marcos K. Aguilera
VMware Research Group
Douglas B. Terry
Samsung Research America

# Многоликость согласованности

Термин согласованности используется во множестве научных компьютерных дисциплин от распределенных систем до баз данных и архитектуры компьютеров.
Отсюда вытекает множество различных понятий которые зависят от того кто их применяет и в каком контексте. Мы делим их на два общих понятия, согласованность состояний и согласованность операций, которые принципиально отличаются по смыслу и области применения. Мы объясним каким образом это проецируются на множестве примеров различных дисциплин.

## Введение

Согласованность это важное понятие в системах с совместно используемыми данными и реплицируемых системах. Изначально компьютерные системы имели только личные данные, однако с их эволюцией от закрытых систем к системам обмена информацией эта информация все больше становилась общей. Совместно используемые данные встречаются во многих типах систем, от распределенных систем до систем баз данных и многопроцессорных систем. К примеру в распределенных системах пользователи шарят по сети свои файлы(исходники), сетевые имена (DNS), бинарные файлы (картинки, хранилища ключ-значение итд), системную метаинформацию (конфигурационные файлы). В системах управления базами данных пользователи шарят таблицы содержащие учетную информацию, описание товаров, информацию о бронировании полетов и учете посадочных мест. В компьютерных системах ядра шарят между собой строки кэша и оперативной памяти. 

В дополнение к совместному использованию компьютерные системы все чаще реплицируют данные внутри и между компонентами.  В распределенных системах, каждый узел может хранить свою локальную реплику файлов, доменных имен или системной информации - эти реплики называются кешем ускоряющим работу системы. Базы данных тоже реплицируют свои строки для повышения производительности и отказоустойчивости. Внутри компьютерных систем части оперативной памяти реплицируются внутрь иерархии кэшей (L1, L2, L3), опять же для повышения производительности. Мы широко используем понятие реплики, как копий данных под управлением конкретной системы.

Во всех этих системах реплицирование и совместное использование поднимают следующий вопрос: что случиться если клиент изменяет данные и одновременно или  в тот же короткий промежуток времени, другой клиент читает или изменяет те же самые данные скажем на другой реплике?

На данный вопрос нет единого верного ответа даже зависящего от контекста. Параметры согласованности зависят от того, каким образом данные меняются или каким образом клиенты наблюдают эти изменения. Возьмем к примеру DNS, изменение доменного имени может изменяться в течении часов и в это время изменения данных могут быть невидимы для многих систем, гарантируется лишь отложенная согласованность. А вот с бронированием мест в самолете дела обстоят иначе, они должны быть видимы моментально всем и быть явно эксклюзивными, чтобы не допустить бронирования двумя пассажирами одного места - например строгая согласованность называется сериализацией. Другие виды согласованности - причинная согласованность (causal consistency), читай то, что записал (read-my-writes), ограниченное устаревание (bounded staleness), беспрерывная согласованность (continuous consistency), блокировочная согласованность (release consistency),  fork consistency (Прим. пер. не могу даже подобрать синоним. В двух словах, если в распределенной системе один из узлов выдает некорректные данные его изолируют), epsilon serializability (Разновидность сериализации, при которой допускаются некоторые временные несогласованности) и еще много разных видов.

Согласованность важна, и программисты должны понимать этот фундаментальный вопрос. Это становится особенно важным, когда клиентом взаимодействующим с системой является не человек, а другая машина, которая должны быть запрограммирована на получение всех возможных результатов ответа.

В этой статье мы рассмотрим каким образом согласованность используется в различных дисциплинах computer science: распределенных системах, системах управления базами данных, архитектуре компьютеров. Мы увидим, что использование согласованности сильно отличается в зависимости от дисциплины. Для лучшего понимания мы разделили согласованность на два типа: согласованность состояния и согласованность операций. Согласованность состояний касается состояния системы и устанавливает ограничения на допустимые связи между разными элементами данных или разными репликами той же системы. Например для согласованности состояния может требоваться, чтобы два хранилища имели одинаковое значение одного и того же элемента, на момент завершения изменения этого элемента. Согласованность операций относится к ограничениям системы на то, какие результаты могут быть возвращены при выполнении этих операций. Например, для обеспечения согласованности операций может потребоваться, чтобы чтение файла возвращало содержимое последней записи в этот файл. Согласованность состояния более простая и часто зависит от приложения, а согласованность операций чаще всего сложнее и не зависит от приложения. По нашему скромному мнению, оба этих важных типа должны быть как можно лучше описаны и сообщество должно как можно больше прилагать к этому усилий.

По мере рассмотрения согласованности в нашей статье, мы больше заостряем внимание на семантике согласованности, а не на механизме ее обеспечения. Семантика отвечает на вопрос какие свойства согласованности обеспечивает система, а не механизм и то каким образом это реализовано в системе. Семантика и механизм очень тесно связаны, но необходимо понимать семантику в отрыве от механизма и реализации.

Остальная часть этой статьи организована следующим образом. В разделе 2 мы объясним абстрактную модель и терминологию которая будет использоваться на протяжении всей статьи. В разделе 3 мы представим два типа согласованности и их различные варианты реализации. В разделе 4 мы покажем в каких видах различные согласованности встречается в различных дисциплинах. 

## 2 Абстрактная модель
Мы принимаем как данность то, что система обрабатывает множественные запросы клиентов. Клиентами могут быть люди, компьютерные программы или системы о которых нам даже не известно. Операции могут включать простые чтение и запись, чтение-изменение-запись, открытие и закрытие транзакции, а также другие различные запросы. Операции обычно выполняют действия над данными, которыми могут быть блоки, файлы, пары ключ-значение, записи DNS, строки таблиц, участки памяти итд.

Система имеет состояние которое выражается в текущем значении элементов данных. В одних случаях нас интересует согласованность отдельных клиентских кэшей и других реплик. А в других случаях, когда кэши и другие реплики находятся в системе и являются частью состояния системы, нас интересует общее состояние.

Выполнение операции не происходит мгновенно, скорее она начинается при отправке пользователем запрос в систему и завершается когда система ответила клиенту результатом выполнения. Если ответ не предусматривает результата, то завершением операции считается время когда система закончит его обработку. Операции и выполнение операций отличаются друг от друга. Операции статичны и в системе их не так много, например операция чтения и операция записи. Выполнения операций же динамические и многочисленные. Клиент можем множество раз отправлять на выполнение одну и ту же операцию, а вот выполенение этой операции всегду будет  уникальным. Хоть мы технически и разделяем эти понятия, в некоторых случаях мы будем размывать границы между этими терминами, например говорить что операция чтения завершена, вместо выполнение операции чтения завершено.

## 3. Два вида согласованности
Нас интересует, что происходит когда шаренные и реплицированные данные  независимо или почти независимо доступны множеству клиентов. Вообще говоря, согласованность накладывает ограничения на допустимые результаты операций в соответствии с потребностями приложения.

Сейчас мы определим два различных типа согласованности. Один накладывает ограничение на состояние, другой на результат выполнения операции.

### 3.1 Согласованность состояния
Согласованность состояния относится к состоянию системы. Согласованность складывается из различных параметров системы, которые будут удовлетворять ожидаемое клиентами состояние, несмотря на одновременный доступ и кучу реплик. Состояние системы также может быть применено при повреждении данных из-за ошибок (сбоев, подмен битов, багов итд.), но это не является целью нашей статьи. Согласованность состояния может состоять из множества разновидностей в зависимости от того каким образом выражаются эти состояния.

#### 3.1.1 Инварианты
Простейшей разновидностью согласованности состояния, является согласованность по инварианту - предикату наложенному на состояние, который должен выполняться со значением истины. Например в параллельных системах, односвязный список не может иметь циклов. В мультипроцессорных системах, если локальный кэш с одним адресом содержится в двух ядрах, то он должен иметь одинаковое значение. В социальных сетях, если пользователь x является другом y, то y является другом x. В приложениях доступа к фотографиям, если фотография содержится в неком альбоме, то альбом является хранителем этой фотографии.

В системах управления базами данных это две важных целостности - уникальность колонки и ссылочная целостность. *Уникальная целостность(uniqueness constraint)* говорит о том, что каждое вставляемое значение в эту колонку, может иметь только одну сопоставленную с ней строку. Это ограничение также известно как первичный ключ.

*Ссылочная целостность(Referential integrity*) заботится о ключе таблицы который ссылается на значение в другой таблице. Ссылочная целостность требует реального наличия ключа в таблице на который ссылаются из другой таблицы. Например в банковской базе данных имеется таблица с учетными данными в которой находится ключ идентификатора пользователя к которому принадлежит этот аккаунт, а также таблица с пользователями где первичным ключом является идентификатором этого пользователя. Ссылочная целостность требует, чтобы пользователь с идентификатором на который ссылается ключ таблицы с учетными данными реально существовал в таблице с пользователями.

Другой вид согласованности основанный на инвариантах это *взаимная согласованность (mutual consistency)*, при которой используется подход реплицирования primary-backup. Взаимная согласованность требует чтобы данные были согласованы на момент отсутствия изменений. В момент же изменений значения реплики может отличаться от значения первичного источника. 

#### 3.1.2 Границы ошибок
Если состояние содержит числовые данные, свойство согласованности может указывать на максимальное отклонение или ошибку от ожидаемого. Например две реплики могут расходиться не более чем на ϵ. В системе интернета вещей, присланное значение, скажем от датчика температуры, может отличаться от реального на ϵ. Первыми концепцию допустимых ошибок предложили в системах управления базами данных, позже ее подхватили распределенные системы.

#### 3.1.3 Пределы количественных нарушений
При достаточно большом объемы параметров согласованности и инвариантов, сложно гарантировать их все, если вообще возможно. В некоторых случаях, можно установить границы допускающие нарушение согласованности или инвариантов. Предположим нарушение инварианта для одного пользователя на миллион, однако только в том случае, если система умеет компенсировать такого рода нарушения.

#### 3.1.4 Важность
Свойства инвариантов могут быть критическими, важными, рекомендуемыми, желательными или опциональными. Только критические инварианты проверяются все время. Разработчики могут использовать более сложные и дорогие механизмы для критических мест и наоборот более дешевые и менее надежные для опциональных. Например при смене пароля на вашем веб сайте, требуется, чтобы он был немедленно заменен на всех репликах и успешность операции считается только после согласования на всех репликах. Такой подход может быть слишком дорогим для менее важных мест.

#### 3.1.5 Отложенные инварианты

Бывают такие инварианты, соблюдение которых не требуется сию секунду, а через какой-то промежуток времени. Так например происходит с *итоговой согласованностью* реплик базы. Им не требуется иметь одинаковое состояние прямо сейчас, а достаточно догнать его после того как перестанут происходить обновления первичной базы данных. Такой механизм используется при репликации в режиме демона или с использованием некоторого механизма на основе анти-энтропии. Отложенная согласованность была введена сообществом распределенных вычислений, хоть и была предложена впервые сообществом управления баз данных, для партиционирования.

### 3.2 Согласованность операций
Свойства согласованности операций относятся к операциям выполняемым клиентами. Они содержат наборы параметров для идентификации корректности ответов подтверждения выполнения операции. Как  будет показано позже, такие параметры могут связывать сразу множество выполняемых операций.

Операционная согласованность имеет подкатегории, для обеспечения различного рода согласованности. Все это мы объясним далее.

#### 3.2.1 Согласованность последовательности
Эта подкатегория определяет разрешенные результаты операций при параллельном выполнении как если бы операции выполняются по одной, без параллелизма. (прим. перев. Разрешенная операция это операция по итогу выполнения которой не нарушены инварианты). Собственно должен быть способ получить все операции любого набора клиентов и организовать их в логически верную цепочку для выполнения. Корректность последовательности выполнения зависит от конкретной системы, однако чаще всего она легко определяется.

Приведем несколько примеров согласованной последовательности.

*Линеаризуемость (Linearizability)* [12] сильная форма согласованности. Выполнение какой-то операции не происходит мгновенно, а имеет некую протяженность, у которой есть начало и конец. Именно эта протяженность и помогает определить последовательность. Мы определяем порядок параллельных операций “<” следующим образом: op1 < op2 если op1 завершилась до начала операции op2. Следовательно должна существовать общая последовательность T всех операций и их результатов в которой:
Все операции в наборе T согласованы через <, что означает что если op1 < op2, то op1 произошла раньше op2 в наборе T.
Была определена корректная последовательность выполнения.
Обычно линеаризуемость использовалась для определения правильного поведения параллельных структур данных; в последнее время она также используется в распределенных системах.

*Последовательная согласованность (Sequential consistency)* [14]  также является сильной формой согласованности, хотя и более слабой, чем линеаризуемость. Несложно понять, что для выполнения такого рода согласованности требуется, чтобы операции выполнялись так, как если бы они были полностью упорядочены, с соблюдением порядка, в котором каждый клиент отправлял операции на выполнение.  Мы определяем порядок параллельных операций “<” следующим образом:  op1 < op2 если обе операции выполнялись одним и тем же клиентом и op1 завершилась до начала выполнения op2. Следовательно должна существовать общая последовательность T всех операций и их результатов в которой:
Все операции в наборе T согласованы через <, что означает что если op1 < op2, то op1 произошла раньше op2 в наборе T
Была определена корректная последовательность выполнения
Эти условия идентичны условиям линеаризуемости, за исключение определения упорядоченности <, которое говорит нам что порядок гарантируется не у всего набора, а только у группы пользователей.

(Прим. переводчика. С моей точки зрения сложно написали, да еще и без картинок. Попробую привести примеры этих последовательностей.
Предположим у нас есть два клиента С1 и С2. В скобочках я буду указывать логическое время вот так С1(1), С1(2) , С2(4), что означает клиент 1 отправил команду в момент времени 1, затем в момент времени 2, а в момент времени 4 клиент два отправил свою команду.
Теперь опишем T таким командами
T - C1(1), C1(2), C1(3), C2(1), C2(2), C2(3)

Предположим, что асинхронное выполнение у нас вернуло следующим образом
R(T) - R(C2(1)), R(C1(1)), R(C2(2)), R(C1(2)), R(C1(3)), R(C2(3))

При линеаризуемости такая последовательность нам не подходит, так как нет строгости последовательности в которой мы их отправили, необходима пересортировка всей последовательности, то есть
R(T) - R(C1(1)), R(C1(2)), R(C1(3)), R(C2(1)), R(C2(2)), R(C2(2))
А вот при последовательной согласованности нас все устраивает, так как последовательность в рамках каждого пользователя не нарушена.)

Следующие примеры относятся к системам поддерживающим транзакционность. Транзакции это пакеты оборачивающие одно или несколько действий которые должны быть выполнены как единое целое. Точнее это операции начала, фиксации и отмены транзакции, а также операций над данными  которые ассоциируются с данной транзакцией. Система обеспечивает уровни изоляции, которые гарантирует, что транзакции не будут существенно мешать друг другу. Существует множество уровней изоляции: serializability, strong session serializability, order-preserving serializability, snapshot isolation, read committed, repeatable reads. Все они относятся к согласованности операций и некоторые из них относятся к разновидности согласованности последовательности. Вот вам несколько примеров из них, все из которых используются в системах управления базами данных.

*Сериализуемость (Serializability)* [5] - Гарантирует, что каждая транзакция пришедшая на обработку будет выполняться последовательно. Если быть более точным, сериализуемость накладывает ограничение на выполнения наборов транзакционных операций от параллельных клиентов в том порядке, как если бы они приходили последовательно от одного. Серийным расписание (serial schedule) называют сериализуемость расписания, то есть выстраивание в последовательность транзакций, а не только операций этих транзакций.

*Строгая сессионная сериализуемость (Strong session serializability)* [8] устраняет проблему сериализуемости. Сериализуемость позволяет транзакциям одного пользователя пересортировываться, что иногда бывает не желательно. Строгая сессионная сериализуемость добавляет условие поверх обычной сериализуемости. Это условие заключается в привязке упорядочивания к сессии, то есть все транзакции должны быть дополнительно упорядочены в рамках ассоциируемой с ними сессией. Если транзакция T1 произошла до транзакции T2 в той же сессии, то T2 не может быть сериализована до T1.

*Сериализуемость с сохранением порядка (Order-preserving serializability)*  [24] - также называемая строгой или жесткой сериализуемостью (strict serializability) [6, 17], требует, чтобы порядок сериализации учитывал порядок транзакций в реальном времени. Ограничение требует соблюдения сериализуемости и что удовлетворяется условие - если транзакция T1 была зафиксирована до момента начала T2, тогда T2 не может быть сериализована до T1.

#### 3.2.2 Ссылочная согласованность (Reference equivalence)
*Ссылочная согласованность (Reference equivalence)* это обобщение согласованности последовательности. Подразумевается определение допустимых результатов выполнения операций, которые бы соответствовали некоторой ссылке. Под ссылкой и соответствием могут подразумеваться различные понятия которые зависят от конкретных свойств согласованности. Сейчас мы дадим несколько примеров транзакционных систем. Эти примеры часто встречаются в контексте систем баз данных.

*Изоляция снимка (Snapshot isolation)* [4] - требует, чтобы транзакции вели себя идентично определенной эталонной реализации, то есть транзакции должны иметь тот же результат, что и в эталонной реализации, а операции должны возвращать те же результаты. Эталонная реализация выглядит следующим образом. В момент начала транзакции ей присваивается монотонная метка времени(прим. пер. В этой статье нет описания монотонности записи и чтения, видимо авторы решили, что читающий и так должен это знать. Если коротко, то это просто метка вектора времени). Когда транзакция читает данные, она читает их из снимка данных, который соответствует метке времени присвоенной транзакции. Когда транзакция T1 пожелала зафиксироваться, система получает монотонную метку времени фиксации транзакции и проверяет не существует ли другой транзакции T2 которая:
1. Обновила те же данные, что и транзакция T1
2. Зафиксировала изменения с меткой времени транзакции T2 между меткой времени начала T1 и меткой времени фиксации T1

Если такая транзакция существует, то действия выполненные транзакцией T1 над снимком будет отменены, если же нет, то все изменения T1 будут зафиксированы с меткой времени фиксации T1.

*Сериализация одной копии (One-copy serializability)* [5] - относится к реплицированной системе баз данных. Реплицированная система должна вести себя как эталонная система, то есть система, которая не реплицируется и обеспечивает сериализуемость. (Прим. переводчика. Подразумевается, что у нас имеются физические копии базы данных над которыми мы параллельно выполняем некие действия. Так вот все эти действия над разными копиями должны быть сериализованы и выполняться в той последовательности и с теми же ограничениями, как если бы мы запускали их на эталонной бд)

*Изоляция снимка одной копии (One-copy snapshot isolation)* [15] - также отностится к реплицируемым базам данных. Требует выполнения изоляции над множеством копий, такой же как если бы копия была всего одна.
#### 3.2.3 Ориентация на чтение и запись

Описанные ранее разновидности согласованности операций применяются в системах с произвольными операциями. Подкатегория же, ориентированная на чтение и запись, применяется в системах со всего двумя, но очень специфическими операциями: чтением и записью. Это довольно важные системы, так как включают множество типов систем хранения, таких как блочные системы хранения, системы хранения ключ-значение и системы доступа к памяти процессора. Деление на две операции, напрямую влияет на семантику выполняемых действий. В частности, операция записи не возвращает никакой информации, кроме подтверждения успешности либо ошибки, что не влияет на согласованность. Таким образом, свойства согласованности сосредоточены только на результатах чтения. Как мы расскажем далее, общим для всех этих свойств согласованности является понятие* видимости чтения,* значений наборов записей. Каждая операция чтения зависит от операций записей в системе; если каждая операция записи охватывает весь элемент данных, то записи перезаписывают друг друга, и операция чтения возвращает значение, записанное одной из них. Но если записи обновляют только часть элемента данных, чтение возвращает комбинацию записанных значений в некотором определенном порядке. В любом случае на результат чтения влияет целый набор записей и без разницы полные ли это перезаписи или только частичные. В таком случае говорят что чтение видит эти записи. Как мы сейчас покажем, понятие *видимости чтения* используется для определения нескольких известных свойств согласованности.

*Читай то, что записал (Read-my-writes)* [21] требует, чтобы операция чтения клиента видела все предыдущие записи этого клиента, причем в точной хронологической последовательности их выполнения. Это свойство актуально когда клиентам требуется видеть свои изменения почти моментально, а вот от других клиентов можно немного и подождать. Обычно подход *“читай то, что записал”* используют в совокупности с другими подходами согласованности ориентированными на чтение-запись такими как *ограниченное устаревание (bounded staleness)* и конечная *отложенная согласованность(operational eventual consistency)*. Впервые подход read-my-writes был определен в распределенных системах  [21] где использовался в компьютерах с моделью общей памяти [19].

*Ограниченное устаревание (bounded staleness)* [1]  ограничивает время в рамках которого записи видны для чтения. В частности это свойство имеет параметр δ, являющийся минимальной границей времени до момента операции чтения, при котором должны быть видны все записи. Это свойство подходит в случаях когда записи за пределами δ не влияют на согласованность либо же когда значения δ малы и незаметны для клиента (например когда δ это десятки миллисекунд и клиенты люди). Впервые ограниченное устаревание было определено в контексте баз данных [1] и позже было применено в контексте распределенных систем [20].

*Операционная отложенная согласованность (operational eventual consistency)* - разновидность отложенной согласованности (формы согласованности состояния) определенной с помощью согласованности операций. Требует, чтобы каждая запись, в конечном итоге была видна всем чтениям, и если клиенты перестали вести обновления, то все чтения по итогу возвращали одинаковые значения [22].

*Когерентность кэша (cache coherence)* произрастает из компьютерной архитектуры для определения корректного поведения кешевой памяти. В частности требуется чтобы чтения и записи одного элемента данных (участка памяти) соблюдали определенные параметры. В различной литературе эти свойства различаются. Единственное требование которое применимо ко всем элементам данных: (1) чтение данных некоторым клиентом всегда возвращает результат последней записи этого клиента, если кто-то не вклинился между его операциями со своим обновлением,
(2) чтение возвращает значение записанное другим клиентом если эти чтение и запись существенно разнесены во времени и между этими двумя операциями не было других операций записи, а также (3) записи были сериализованы.

### 3.3 Обсуждения
Сейчас мы сравним согласованность состояния и согласованность операций в терминологии их уровня абстракции, сложности, мощности и зависимости от приложения.

#### 3.3.1 Уровень абстракции
Согласованность операций это сквозное свойство, поскольку оно имеет дело с результатами которые непосредственно наблюдают клиенты. Согласованность операций контрастирует с согласованностью состояния системы которую клиенты могут наблюдать только косвенно путем выполнения операций. Другими словами согласованность операций находится на более высоком уровне абстракции чем согласованность состояния. В результате чего система может иметь существенную
несогласованность состояния, но скрывать это для внешних наблюдателей путем согласованности операций.
Интересный пример системы хранения с тремя серверами в репликации кворума большинства (majority quorums) [3], где (1) при записи фиксируется метка времени и  записываются данные на два (большинство) сервера, при чтении (2) система обращается к двум серверам (большинству), выбирает оттуда данные и проверяет их временные метки, если метки оказались одинаковыми, система возвращает данные клиенту, если же метки отличаются, система записывает данные с большей временной меткой на сервер с меньшей временной меткой, чтобы нивелировать возможность потери информации и возвращает данные с большей меткой клиенту. Такая система нарушает общую согласованность системы, так как если не происходит расхождений при таких операциях, то отстающий сервер так и не получит обновления и останется отстающим. Однако это не приведет к рассогласованности получаемых данных при чтении, так как фильтрация при выполнении запросов этого не допустит. По факту эта система хранения удовлетворяет линеаризуемости, одной из строгих форм согласованности.

#### 3.3.2 Сложность
Операционная согласованность более сложная чем согласованность состояния. В случае согласованности состояния программист может ясно понять от чего зависит согласованность и чего ожидать от системы. Каждое свойство относится к конкретным элементам данных, которые не зависят от выполнения. Как результат, согласованность состояния гораздо более простая и интуитивная. Более того ее легко проверить, достаточно получить снимок состояния системы и проверить его значение. Это значительно упрощает отладку.
По условию, операционная согласованность устанавливает связь между операциями которые разнесены во времени между разными клиентами. Эта сложность делает операционную согласованность менее интуитивной и сложной в понимании, как мы показывали в разделе 3.2. Более того, отладка согласованности операций требует проверки логов выполнения, что делает ее еще более сложной.
#### 3.3.3 Возможности

Согласованность операций и согласованность состояния имеют разные возможности. Операционная согласованность видит все изменения в системе, что позволяет обеспечить порядок и результат операций. Если система детерминирована, свойство операционной согласованность позволяет восстановить состояние из операций, тем самым косвенно выполнить ограничения согласованности состояния. Но это сделать не реально, если система не детерминирована (например из-за параллелизма, таймингов или внешних событий).

С другой стороны согласованность состояния позволяет видеть всю картину целиком и ограничивать операции которые способны нарушить это состояние. Если система записывает все свои операции в своем состоянии, то согласованность состояний может косвенно ограничивать результаты операций во многом подобно согласованности операций. Однако часто запись всех операций это непозволительная роскошь.
#### 3.3.4 Зависимость от приложения
Согласованность состояния имеет склонность зависеть от приложения, так как понятие согласованности может очень сильно меняться от приложения к приложению. Как результат разработчикам приходится выяснять каждое условие согласованности, что затратно по времени и усилиям. Более того, иногда обычных механизмов оказывается не достаточно и разработчикам приходится внедрять в бизнес логику код обеспечивающий согласованность. Два самых распространенных исключения: взаимная согласованность и итоговая согласованность. Эти свойства широко применяются к любой реплицированной системе, ссылаясь на реплицированное состояние независимо от приложения, и существуют общие механизмы репликации для обеспечения соблюдения таких свойств.

Согласованность операций часто не зависит от приложения. Обеспечивается независимость двумя способами. Во первых некоторые свойства исключают фактор зависимости от приложения путем разделения операций на несколько параллельных потоков операций, которые ведут себя как последовательное выполнение (*пример согласованности последовательности*) или ссылочного поведения (*пример ссылочной согласованности*). Во вторых некоторые свойства сфокусированы на типах операций, например чтение и запись, которые применяются ко множеству систем (например категории ориентированные на чтение и запись). Теоретически, операционная согласованность может довольно сильно зависеть от приложения, но это частные случаи. Например система доступа к email со множества устройств, в которых операции (чтения, записи, перемещения), могут иметь различные условия результирующих ответов в зависимости от семантики приложения и ожидания пользователей.

#### 3.3.5 Что же использовать?
Чтобы решить какой тип использовать, мы рекомендуем принять ко вниманию несколько моментов. Первое о чем стоит задуматься это отсутствие согласованности: какой несогласованности стоит избегать? Если на этот вопрос проще всего ответить рассинхронизацией состояния (например расхождение двух реплик), тогда используйте согласованность состояния. Если же ответ проще всего описать не корректным результатом выполнения операции (например чтение возвращает устаревшие данные), то используйте согласованность операций.

Второе о чем стоит задуматься - зависимость от приложения. Многие свойства согласованности состояния и согласованности операций не зависят от приложения (например, сериализуемость, линеаризуемость, взаимная согласованность, итоговая согласованность). Мы рекомендуем постараться в первую очередь ограничиться этими свойствами, до того как перейти к приложения-зависимым, так как механизмы для их реализации легко понимаемы. Если же системе требуется свойство зависящее от приложения, а согласованность состояния и согласованность операций подходят в одинаковой мере, то мы рекомендуем использоваться согласованность состояния из-за его простоты.

## 4. Согласованность в различных дисциплинах
Теперь мы обсудим, что же подразумевают понятия согласованности в различных дисциплинах, почему они актуальны в этих дисциплинах и как это связано с двумя типами согласованности описанными в разделе 3. Мы также покажем концепции, которые считаются согласованными в одной дисциплине, но не в другой.

### 4.1 Распределенные системы
В распределенных системах согласованность означает согласованность состояния или операции. Ранние протоколы репликации фокусировались на общей согласованности в то время как распределенные облачные системы обеспечивали итоговую согласованность. Это примеры согласованности состояния. Некоторые системы нацелены на обеспечение линеаризуемости или различных вариантов согласованности, ориентированной на чтение-запись. Это примеры согласованности операций.

Согласованность - заслуживает особого внимания в распределенных системах, потому что такие системы сталкиваются со множеством проблем, которые препятствуют или затрудняют согласованность: клиенты разделены медленным соединением, машины отказывают, клиенты теряют соединения, масштабирование системы для большого количества клиентов, высокая доступность. Эти проблемы могут сильно усложнять выполнение свойств сильной согласованности, так как это требует координации клиентов, что далеко не всегда бывает возможным. В результате распределенные системы могут принимать более слабые уровни согласованности, выбранные в соответствии с потребностями приложений.

Облачные системы, особенно интересный тип распределенных систем, так как они постоянно сталкиваются со всеми перечисленными выше проблемами: системы размазаны по всему миру с огромными задержками между дата центрами; машины постоянно отказывают из-за перегрузки; клиенты постоянно отваливаются из-за проблем с сетью; некоторые клиенты подключены постоянно и нужно держать соединения открытыми; система должна быть доступна так долго как это возможно иначе бизнес теряет деньги во время простоя. Из-за всех этих трудностей распределенные системы выбирают слабую согласованность.

### 4.2 Системы баз данных
В системах баз данных согласованность означает согласованность состояний. Например акроним ACID означающий гарантированность транзакции. “С” означает согласованность, что в терминологии баз данных означает состояние, которое программисты называют корректностью. Система содержит инварианты которые должны гарантировать согласованность: уникальность, ссылочную целостность, заточенные под приложения (например  x является другом y если y является другом x). Это все вырисовывается в согласованность состояния.

“A” означает атомарность (atomicity), “I” означает изолированность (isolation). Интересно, что атомарность и изолированность это не что иное как согласованность операций. Атомарность требует, чтобы транзакция либо выполнялась полностью, либо не выполнялась вообще, в то время как изоляция требует, чтобы транзакции выполнялись сами по себе без особого вмешательства. Существует множество видов уровней изоляции  (serializability, snapshot isolation, read committed, repeatable reads, etc), но все они выполняют согласованность операций.

Несмотря на то что комьюнити субд отделяет изоляцию транзакции от согласованности и атомарности, в распределенных системах изоляция это форма согласованности, в то время как в сообществе компьютерной архитектуры концепция аналогичная изоляции, называется атомарностью. Мы на самом деле не знаем откуда такие различия в терминологиях разных сообществ. Но мы подозреваем, что причина в том, что в этих концепциях есть взаимосвязанные идеи, которые мы пытаемся выявить и прояснить в этой статье.

Согласованность очень важна для систем баз данных, так как данные это первичная забота таких систем, по сути в таких система данные куда более важны, чем результат операции (например операции могут завершаться неудачей пока данные не будут удалены). Разные типы согласованность возникают из-за разных типов инвариантов, существующих в базе данных, каждый со своим собственным механизмом соблюдения. Например уникальность обеспечивается индексом и проверкой в движке выполнения; специфичные для приложения проверяются бизнес логикой; общая согласованность обеспечивается менеджером репликации.

### 4.3 Архитектура компьютера
В компьютерной архитектуре согласованность означает согласованность операций. Похожая концепция называемая когерентностью также является согласованностью.Согласованность и когерентность имеют некоторые отличия. Согласованность касается всей системы памяти; она обеспечивает поведение чтения и записи называемые выгрузкой(loads) и загрузкой(stores) всей системы памяти, это яркий пример свойства согласованности последовательности. Когерентность относится к подсистеме кэширования; это можно рассматривать как согласованность операций различных кэшей, отвечающих за данную ячейку памяти. Таким образом, когерентность ограничивает поведение выгрузок и загрузок в отдельной ячейке памяти.

Согласованность и когерентность разделены, чтобы обеспечить модульную архитектуру системы: протокол когерентности кэша обеспечивает правильное поведение подсистемы кэширования, в то время как остальная часть системы обеспечивает согласованность при доступе к памяти, не беспокоясь о подсистеме кеширования.

Задачи согласованности и когерентности возникли в компьютерной архитектуре, из-за того, что компьютерные системы все чаще обеспечены многоядерностью или многопроцессорностью, совместно использующими0 доступ к общей памяти: в таких системах существуют параллельные операции с ячейками памяти и репликация данных во многих кэшах, что приводит к проблемам с совместным использованием данных.

## 5. Заключение

Согласованность это проблема охватывающая множество дисциплин. Все это связано с ростом параллелизма и репликации в этих дисциплина и мы ожидаем, что тенденция сохранится. Согласованность скользкая штуковина, ее сложно понять, а что еще хуже, так это то, что она имеет разные термины и значения в различных сообществах. Мы надеемся пролить немного света на это, выделив две крупных подкатегории - согласованность состояния и согласованность операций, которые присущи всем из дисциплин.

##### References

[1] R. Alonso, D. Barbara, and H. Garcia-Molina. Data caching issues in an information retrieval system. ACM Transactions on Database Systems, 15(3):359–384, Sept. 1990.

[2] P. A. Alsberg and J. D. Day. A principle for resilient sharing of distributed resources. In International Conference
on Software Engineering, pages 562–570, Oct. 1976.

[3] H. Attiya, A. Bar-Noy, and D. Dolev. Sharing memory robustly in message-passing systems. Journal of the ACM,
42(1):124–142, Jan. 1995.

[4] H. Berenson, P. A. Bernstein, J. Gray, J. Melton, E. J. O’Neil, and P. E. O’Neil. A critique of ANSI SQL isolation
levels. In ACM SIGMOD International Conference on Management of Data, pages 1–10, May 1995.

[5] P. A. Bernstein, V. Hadzilacos, and N. Goodman. Concurrency Control and Recovery in Database Systems. AddisonWesley, 1987.

[6] P. A. Bernstein, D. W. Shipman, and W. S. Wong. Formal aspects of serializability in database concurrency control.
IEEE Transactions on Software Engineering, 5(3):203–216, May 1979.

[7] Y. Breitbart, H. Garcia-Molina, and A. Silberschatz. Overview of multidatabase transaction management. VLDB
Journal, 1(2):181–239, Oct. 1992.

[8] K. Daudjee and K. Salem. Lazy database replication with ordering guarantees. In International Conference on Data
Engineering, pages 424–435, Mar. 2004.

[9] S. B. Davidson, H. Garcia-Molina, and D. Skeen. Consistency in partitioned networks. ACM Computing Surveys,
17(3):341–370, Sept. 1985.

[10] K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. Memory consistency and event
ordering in scalable shared-memory multiprocessors. In International Symposium on Computer Architecture, pages
15–26, June 1990.

[11] J. L. Hennessy and D. A. Patterson. Computer Architecture: A Quantitative Approach. Morgan Kaufmann, fifth
edition, Sept. 2011.

[12] M. Herlihy and J. Wing. Linearizability: A correctness condition for concurrent objects. ACM Transactions on
Programming Languages and Systems, 12(3):463–492, July 1990.

[13] P. W. Hutto and M. Ahamad. Slow memory: Weakening consistency to enhance concurrency in distributed shared
memories. In International Conference on Distributed Computing Systems, pages 302–309, May 1990.

[14] L. Lamport. How to make a multiprocessor computer that correctly executes multiprocess programs. IEEE Transactions on Computers, C-28(9):690–691, Sept. 1979.

[15] Y. Lin, B. Kemme, M. Patino-Mart ˜ ´ınez, and R. Jimenez-Peris. Middleware based data replication providing snapshot ´
isolation. In ACM SIGMOD International Conference on Management of Data, pages 419–320, June 2005.

[16] D. Mazieres and D. Shasha. Building secure file systems out of byzantine storage. In ` ACM Symposium on Principles
of Distributed Computing, pages 108–117, July 2002.

[17] C. H. Papadimitriou. The serializability of concurrent database updates. Journal of the ACM, 26(4):631–653, Oct.
1979.

[18] K. Ramamritham and C. Pu. A formal characterization of epsilon serializability. IEEE Transactions on Knowledge
and Data Engineering, 7(6):997–1007, Dec. 1995.

[19] A. Tanenbaum and M. V. Steen. Distributed systems. Pearson Prentice Hall, 2007.

[20] D. B. Terry. Replicated data consistency explained through baseball. Communications of the ACM, 56(12):82–89,
Dec. 2013.

[21] D. B. Terry, A. J. Demers, K. Petersen, M. Spreitzer, M. Theimer, and B. W. Welch. Session guarantees for weakly
consistent replicated data. In International Conference on Parallel and Distributed Information Systems, pages 140–
149, Sept. 1994.

[22] D. B. Terry, V. Prabhakaran, R. Kotla, M. Balakrishnan, M. K. Aguilera, and H. Abu-Libdeh. Consistency-based
service level agreements for cloud storage. In ACM Symposium on Operating Systems Principles, pages 309–324,
Nov. 2013.

[23] D. B. Terry, M. M. Theimer, K. Petersen, A. J. Demers, M. J. Spreitzer, and C. H. Hauser. Managing update conflicts
in Bayou, a weakly connected replicated storage system. In ACM Symposium on Operating Systems Principles, pages
172–183, Dec. 1995.

[24] G. Weikum and G. Vossen. Transactional Information Systems: Theory, Algorithms, and the Practice of Concurrency
Control and Recovery. Morgan Kaufmann, 2009.

[25] H. Yu and A. Vahdat. Design and evaluation of a conit-based continuous consistency model for replicated services.
ACM Transactions on Computer Systems, 20(3):239–282, Aug. 2002
